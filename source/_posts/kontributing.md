---
title: Kontributing
date: 2020-04-25 15:53:29
tags:
---

I'm trapped in quarantine due to the global COVID-19 pandemic. I accept that. I also know that I need to develop


1. Start with the newest version of IntelliJ IDEA. I already had a 2019 version of the Community Edition installed, but the Kotlin project wouldn't build under that configuration. I updated to the latest 2020.1 version of the IDE, I also updated all my plugins. I repeatedly saw build issues around generated code, eventually I resolved these by ensuring that I had downloaded JDK versions 1.6, 1.7, 1.8, and 9; each of these is needed to assemble the project (and don't forget to update your environment variables if you, like me, didn't have some of these legacy versions installed).

2. Import the project. I cloned the main Kotlin repo, opened the project with IntelliJ, and then the waiting game began. It's a big project, so be patient with the first build. Subsequent builds were much faster thanks to incremental recompilation.

3. Find an issue that needs attention! The contributing guidelines directed me towards a query into the Kotlin issue tracker that listed a number of issues suitable for new contributors. They were all tagged "Up For Grabs". At the time of writing there seemed to be lots of activity from new contributors towards working to create samples for all the functions in the standard library, this aligns with my interest in well documented code; I decided to target adding more of these samples as my first contribution. The issue requested that I make a comment on it stating which functions I was going to work on, then I could get to work.

4. Implement a change. This is the meat and potatoes of the task, and depending on what you're targeting and how experienced you are with Kotlin you may spend many countless hours on this step. In my case I needed to identify which functions in the standard library didn't have samples provided. I looked through the documentation and found that the `Collections` portion of the library seemed to be halfway done. I'm somewhat familiar with these APIs from having used them on the job, so it seemed natoral to me to start there. It was at this point that I learned that much of this documentation, and indeed some of the standard library itself, was generated from a custom Kotlin DSL (Domain-Specific Language). I wasn't expecting this at all, but after taking some time to consider it the benefits became apparent: since the Collections system seeks to provide a unified method of interacting with the many different individual classes that Kotlin has for dealing with groups of objects (`Map`, `Set`, `Array`, `List`, etc.), unifying the development and documentation of this functionality is natural. After all, the goal is for developers to be able to rely on the standard functions related to these collections (`map`, `filter`, `join`, `sort`, etc.) operating consistently across the different collection types. Because the code for some of these collection classes was generated by this DSL, I had to execute the generator itself in order to even see all the classes in my IDE. Luckily this detail was noted in the contributing documents, otherwise I'm sure I would have fumbled around confused for a long time. After succeeding in generating the _full_ source for the collections, I implemented my first sample for the function. I kept things simple, using as plain a set of test data as I could think of, then added a link to my function (tagged and set up as a variation on a unit test) to the KDoc.

5. Make a commit. I was slightly surprised to see that the project doesn't enforce any real guidelines on how commit messages should be formatted, so I simply wrote a message describing my small change.

6. Push to a fork of the Kotlin repository. The main Kotlin project on GitHub doesn't accept pushes from the public, rather you are to fork the repository to your own account, push to that fork, then make a Pull Request back to the original. I've gotten used to this process over the years, but if it's your first time going through it I'd suggest going slowly and ensuring that you've got the different upstream repositories named correctly on your local machine, and that you are pushing to the correct one rather than letting muscle memory take over when punching in git commands. I personally like to keep `origin` pointing to the main repository from which I cloned the code, and add a second remote that points to my fork of the code. I call this `fork`, so the command to push my branch would look like `$ git push fork <BRANCH_NAME>`.

7. Make your Pull Request back to the Kotlin Repository. Now that I had my changes up on my fork I just needed to make a Pull Request back to the original. The Kotlin project doesn't have a standard format for PRs, so I again just described my small change and linked out to the issue tracker for completeness.

8. Wait. The maintainers of Kotlin are busy people, they'll get to your work when they have time.

